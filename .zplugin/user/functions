
# Load zsh-completion-generator when needed and unload when done
generatecomp(){
    zplugin ice from"gh" silent pick"zsh-completion-generator.plugin.zsh" blockf;
    zplugin light RobSis/zsh-completion-generator && gencomp $1;
    zplugin creinstall -q RobSis/zsh-completion-generator;
    zplugin unload -q RobSis/zsh-completion-generator;
}

auto-ls-modecheck(){
    if tlp-stat -s | grep -q 'Mode           = battery'; then
        varcache=("${AUTO_LS_COMMANDS[@]}")
        AUTO_LS_COMMANDS=("${AUTO_LS_COMMANDSBAT[@]}")
        auto-ls
        AUTO_LS_COMMANDS=("${varcache[@]}")
        break
    fi
}

auto-ls-colorls(){
    if [[ $(git rev-parse --is-inside-work-tree 2> /dev/null) == true ]]; then
    colorlsprefix+=("${colorlsgitprefix[@]}")
    fi
    colorls "${colorlsprefix[@]}"
}

# Aesthetic function for Dolphin, clear -x if cd while in Dolphin
if [[ $(xdotool getwindowfocus getwindowname) = *Dolphin* ]]; then
    function cd () { builtin cd "$@" && clear -x; }
fi

#
dotscheck(){
  dotsvar1=("${dotsvar[@]/%/'}")
  dotsvar2=("${dotsvar1[@]/#/-e '}")
  dotsvar3=(grep -v "${dotsvar2[*]}")
  dotsvar4=$(dots status | eval "${dotsvar3[*]}")
  if echo "$dotsvar4" | grep -q -e "Changes not staged" && echo "$dotsvar4" | grep -q -e "modified" || echo "$dotsvar4" | grep -q "Changes to be committed"; then
      dots status
  elif echo "$dotsvar4" | grep -q "ahead of"; then
      dots status
      dots push
  elif echo "$dotsvar4" | grep -q "is behind"; then
    dots status
  fi
}

# Update locally built git projects
updatelocal(){
  trap "loadautols; return 0" SIGINT
  zplugin unload -q desyncr/auto-ls
  popit=false
  if [[ $gdir != "$PWD" ]]; then popit=true; fi
  if [[ $1 = "-p" || $1 = "--pwd" || $2 = "-p" || $2 = "--pwd" || $1 = "-r" || $1 = "--repull" ]]; then
    popit=false
    gdir=$PWD
  fi

  pushd $gdir || return 1
  colorls -d

  loadautols(){
    zplugin ice load'[[ $(xdotool getwindowfocus getwindowname) != *Dolphin* ]]'
    zplugin load desyncr/auto-ls
  }

  fetchupdates(){
    if [[ $(git rev-parse --show-toplevel 2>/dev/null) = "$PWD" ]]; then
      git fetch -j$(nproc)
      echo "Fetching $PWD..."
    fi
  }

  checkupdates(){
    if [[ $(git rev-parse --show-toplevel 2>/dev/null) = "$PWD" ]]; then
      UPSTREAM=${1:-'@{u}'}
      LOCAL=$(git rev-parse @)
      REMOTE=$(git rev-parse "$UPSTREAM")
      BASE=$(git merge-base @ "$UPSTREAM")

      if [ $LOCAL = $REMOTE ]; then
        echo "Up-to-date $PWD"
      elif [ $LOCAL = $BASE ]; then
        echo -e "\e[00;31mNeed to pull $PWD\e[00m"
      elif [ $REMOTE = $BASE ]; then
        echo -e "\e[00;31mNeed to push $PWD\e[00m"
      else
        echo -e "\e[00;31mDiverged $PWD\e[00m"
      fi
    fi
  }

  changelogs(){
    if [[ $(git rev-parse --show-toplevel 2>/dev/null) = "$PWD" ]]; then
      upstream=$(git status | grep "On branch " | awk -F"branch " '{print $NF}')
      changes=$(git log $upstream..origin/$upstream)

      if [[ $changes ]]; then echo "BEGIN----------------------------------------------------"
      echo "$PWD"; fi
      git log --color=always --graph --pretty='''%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset''' --stat $upstream..origin/$upstream
      if [[ $changes ]]; then echo "$PWD"; echo "------------------------------------------------------END"
      echo ""; fi
    fi
  }
  case $1 in
    --changes )
      { for d in ./*/ ; do (builtin cd "$d" && checkupdates); done
      echo ""
      for d in ./*/ ; do (builtin cd "$d" && changelogs); done } | less -R
      ;;
    --repull | -r )
      echo "Assuming --pwd"
      echo "Are you sure you want to repull $PWD"
      IFS=
      read -n 1 key
      if [ "$key" = "" ]; then
        git reset --hard; git clean -fdx; git pull
      fi
      ;;
    * )
      echo "Fetching latest updates..."
      for d in ./*/ ; do (builtin cd "$d" && fetchupdates); done
      echo ""
      for d in ./*/ ; do (builtin cd "$d" && checkupdates); done
      echo ""
      ;;
  esac

  if $popit; then popd 2> /dev/null; unset popit; fi
  loadautols
}
